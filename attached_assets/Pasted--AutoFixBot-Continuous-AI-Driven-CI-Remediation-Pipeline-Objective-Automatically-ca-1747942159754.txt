# **AutoFixBot – Continuous AI‑Driven CI Remediation Pipeline**

> **Objective:** Automatically capture any failing GitHub Actions workflow logs, forward them to a hosted Replit AI agent (or OpenAI function), receive corrective suggestions/patches, and apply fixes via Pull Request—all within minutes.

---

## 1 • High‑Level Architecture

```
┌────────────┐      workflow_run (completed)      ┌──────────────┐
│ GitHub CI  │───────────────────────────────────▶│  AutoFixBot  │
└────────────┘   (status=failure) via webhook     └──────────────┘
       ▲                                              │
       │  PR with patch / issue comment               │ calls LLM
┌──────┴──────┐  (GitHub REST API)                    ▼
│ Source Repo │◀─────────────────────────────────┌──────────────┐
└─────────────┘                                  │  Replit AI   │
                                                 └──────────────┘
```

1. **workflow\_run Webhook** – Fires whenever a workflow finishes. Filter for `conclusion=failure`.
2. **AutoFixBot (GitHub App)** – Small Node/Go service deployed on Replit, subscribes to webhook; pulls the job logs via REST API.
3. **Prompt Construction** – Bot builds a prompt: *“Here is the failing step log… Suggest a fix and return a git‑patch.”*
4. **LLM Invocation** – Replit AI/OpenAI completes with a patch diff or step rewrite.
5. **Apply Fix** – Bot creates a branch `autofix/<sha>` and commits patch; opens PR with description.
6. **CI Re‑runs** – GitHub automatically triggers CI on the PR; if green and maintainer approves, merge.

---

## 2 • Implementation Steps

### 2.1 Create GitHub App

* Permissions: `issues`, `pull_requests`, `actions:read`, `contents:write`.
* Webhook events: `workflow_run`.

### 2.2 Deploy Bot on Replit

* Use **Replit Deployments** container.
* Env vars: `GH_APP_ID`, `GH_PRIVATE_KEY`, `OPENAI_API_KEY`.
* Expose HTTPS endpoint `/webhook`; verify signature.

### 2.3 Prompt Template (example)

```text
You are an expert Android CI engineer. The following GitHub Actions step failed:
---
${{log_snippet}}
---
Return ONLY a unified git patch that fixes the problem, or a markdown comment if informational.
```

### 2.4 Patch Application Logic

1. Parse completion: if begins with \`\`\`diff produce commit.
2. Write patch file to repo directory.
3. `git apply`, commit, push branch via REST API.
4. PR title: “AutoFix: CI failure on \${{workflow\.name}}”.

### 2.5 Safety & Rate Limits

* **Token Budget** – Truncate logs to last 4000 chars.
* **Retry ≤3** if LLM returns invalid diff.
* **Manual Review** – PR requires human approval before merge.

---

## 3 • Sample GitHub Action (Webhook Dispatcher)

```yaml
# .github/workflows/dispatch.yml
name: Post‑CI Webhook
on:
  workflow_run:
    types: [completed]
jobs:
  notify:
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger AutoFixBot
        env:
          WEBHOOK_URL: ${{ secrets.AUTOFIXBOT_URL }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          curl -X POST -H "Authorization: token $GH_TOKEN" \
               -H "Content-Type: application/json" \
               -d '{"run_id": "${{ github.event.workflow_run.id }}"}' \
               "$WEBHOOK_URL"
```

---

## 4 • Limitations & Considerations

* Complex multi‑line fixes may need iterative PRs.
* Binary/secret files excluded from patches.
* LLM suggestions should be scanned by **OWASP DC** before merge.

---

## 5 • Next Steps

1. Register GitHub App and configure webhook secret.
2. Fork `AutoFixBot` template repo (e.g., using Probot).
3. Deploy to Replit; test with a deliberately failing Action.
4. Iterate on prompt & patch validation rules.

---

**Outcome:** Failures in GitHub CI are auto‑triaged, patched, and surfaced as PRs within minutes—closing the loop between detection and remediation with minimal human effort.
